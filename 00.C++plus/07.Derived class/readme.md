C++ 派生类知识总结
===========

1\. 基本概念
--------

派生类（Derived Class）是基于一个或多个已存在的类（基类或父类）创建的新类。派生类继承了基类的属性和行为，但也可以定义新的属性和行为或者重写继承的行为。

2\. 基类与派生类
----------

cpp

```cpp
class Base {
    // ... 基类内容 ...
};

class Derived : public Base {
    // ... 派生类内容 ...
};
```

在上述代码中，`Derived` 是从 `Base` 类派生出来的。

3\. 访问控制
--------

*   `public` 继承：基类的公有成员在派生类中为公有成员，基类的保护成员在派生类中为保护成员，基类的私有成员不可直接访问。
*   `protected` 继承：基类的公有和保护成员在派生类中都为保护成员。
*   `private` 继承：基类的公有和保护成员在派生类中都为私有成员。

4\. 构造函数与析构函数
-------------

*   派生类的构造函数默认不会调用基类的默认构造函数，除非明确调用或初始化。
*   派生类的析构函数在执行完成后会自动调用基类的析构函数。

5\. 函数重写
--------

派生类可以重写基类中的成员函数，但基类函数必须声明为 `virtual`。

6\. 多态
------

通过基类指针或引用调用虚函数时，会根据指针或引用所指向的对象的实际类型来调用相应的函数版本，这称为多态。

7\. 抽象类
-------

如果基类中有纯虚函数（没有定义的虚函数），则这个类是抽象类，不能创建该类的对象。

8\. 多重继承
--------

C++ 支持从多个基类派生出一个类，但这可能导致一些问题（如菱形继承问题）。

cpp

```cpp
class Base1 { /* ... */ };
class Base2 { /* ... */ };

class Derived : public Base1, public Base2 {
    // ... 派生类内容 ...
};
```

9\. 组合与继承
---------

组合是另一种常见的代码重用方式，其中一个类包含另一个类的对象，而不是从另一个类派生。

---

# C++ 继承方式的访问权限

以下是一个关于C++中各种继承方式的访问权限的表格：

| 基类访问修饰符 | `public` 继承 | `protected` 继承 | `private` 继承 |
|----------------|--------------|-----------------|---------------|
| `public`      | `public`    | `protected`    | `private`    |
| `protected`   | `protected` | `protected`    | `private`    |
| `private`     | 不可访问    | 不可访问       | 不可访问     |

## 说明:

1. **`public` 继承**：基类的 `public` 成员在派生类中仍为 `public`，基类的 `protected` 成员在派生类中仍为 `protected`，而基类的 `private` 成员在派生类中不可访问。

2. **`protected` 继承**：基类的 `public` 和 `protected` 成员在派生类中都变为 `protected`，基类的 `private` 成员在派生类中不可访问。

3. **`private` 继承**：基类的 `public` 和 `protected` 成员在派生类中都变为 `private`，基类的 `private` 成员在派生类中不可访问。

注意：无论继承方式如何，基类的 `private` 成员始终在派生类中都是不可访问的。



以上是 C++ 派生类的基本知识总结。继承是面向对象编程的四大特性之一，与封装、多态和抽象一起，为 C++ 提供了强大的编程能力。


虚函数 (Virtual Functions) in C++
==============================

虚函数是C++中用于支持多态性的一种机制。通过使用虚函数，可以达到在基类指针或引用上调用派生类的函数实现的效果。

定义
--

在C++中，当我们在基类中声明一个函数为`virtual`时，它就成为了虚函数。这意味着，如果该函数在派生类中被重写，那么通过基类的指针或引用调用该函数时，会调用派生类中的版本。

cpp

```cpp
class Base {
public:
    virtual void show() {
        cout << "This is Base class." << endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        cout << "This is Derived class." << endl;
    }
};
```

为什么使用虚函数？
---------

*   **支持多态性**：多态性是面向对象编程的一个核心概念，它允许我们通过基类接口来操作不同的派生类对象。

*   **动态绑定**：在运行时，C++使用虚函数表（vtable）来动态决定应该调用哪个函数版本。这意味着，直到运行时，才会确定实际调用哪个函数。

注意事项
----

*   **纯虚函数**：如果一个虚函数在基类中没有定义实现，并且被初始化为0，那么它就是纯虚函数。包含纯虚函数的类是抽象类，不能直接实例化。

*   **虚析构函数**：如果一个类有虚函数，那么它的析构函数通常也应该是虚的。这确保了当通过基类指针删除派生类对象时，派生类的析构函数也会被调用。

*   **性能**：虚函数调用涉及到查找虚函数表，这可能会比非虚函数调用稍微慢一些。但在大多数情况下，这种性能差异是可以忽略的。

示例
--

cpp

```cpp
Base* obj = new Derived();
obj->show();  // Outputs: "This is Derived class."
delete obj;
```

在上述代码中，尽管`obj`是一个基类指针，但由于`show`函数是虚函数，所以调用的是`Derived`类中的`show`函数实现。