C++ Class Knowledge
===================

在 C++ 中，类是创建对象的蓝图。它定义了对象的属性和方法。

构造函数
----

构造函数是一个特殊的成员函数，当创建类的对象时会自动调用它。它的名称与类的名称相同，并且没有返回类型。

### 示例：

cpp

```cpp
class MyClass {
public:
    MyClass() {
        // 构造函数代码
    }
};
```

初始化列表的构造函数
----------

初始化列表是在构造函数之前初始化数据成员的一种方法。它直接在数据成员的内存位置上初始化值，而不是先创建一个默认对象，然后再赋值。这可以提高效率。

### 示例：

cpp

```cpp
class MyClass {
private:
    int myVar;

public:
    MyClass(int a) : myVar(a) {
        // 构造函数代码
    }
};
```

在上面的示例中，`myVar` 会在构造函数体执行之前使用初始化列表的值进行初始化。

总结
--

构造函数和初始化列表是 C++ 类中的重要概念。构造函数确保当对象被创建时，它会有一个有效的状态。而初始化列表提供了一种更高效的初始化数据成员的方法。


explicit概念
============

`explicit` 是 C++ 中的一个关键字，用于防止不希望发生的隐式类型转换。它主要与类的构造函数一起使用，以确保只有在明确要求时才进行类型转换。

为什么需要 `explicit`？
-----------------

考虑以下情况：你有一个类，该类有一个接受单一参数的构造函数。由于这样的构造函数可以用来将其他类型的值转换为你的类的对象，所以它可以被用作一个隐式转换。

这可能会导致一些不期望的行为。例如，你可能会意外地调用这个构造函数，而不是你原本打算调用的其他函数。

为了避免这种情况，你可以使用 `explicit` 关键字来修饰这样的构造函数，这样编译器就不会在不需要的时候自动使用它进行隐式转换了。

示例
--

cpp

```cpp
class MyNumber {
    int value;
public:
    explicit MyNumber(int a) : value(a) {}
};

void printNumber(MyNumber num) {
    // ... some code ...
}

int main() {
    // MyNumber n = 42;  // 这行会编译错误，因为我们使用了 explicit
    MyNumber n(42);     // 这是正确的
    printNumber(n);     // 这也是正确的
    // printNumber(42); // 这行会编译错误，因为不允许隐式转换
}
```

在上面的例子中，由于 `MyNumber` 的构造函数被声明为 `explicit`，所以不能隐式地将 `int` 转换为 `MyNumber`。